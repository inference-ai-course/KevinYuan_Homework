2510.26692v1 [cs.CL] 30 Oct 2025

arXiv

G3 Kimi LINEAR:

AN EXPRESSIVE, EFFICIENT ATTENTION ARCHITECTURE

Performance

45

Figure 1:
red stars),
achieving

TECHNICAL REPORT OF KIMI LINEAR

Kimi Team
© https: //github.com/MoonshotAI/Kimi-Linear

ABSTRACT

We introduce Kimi Linear, a hybrid linear attention architecture that, for the first time, outperforms
full attention under fair comparisons across various scenarios—including short-context, long-context,
and reinforcement learning (RL) scaling regimes. At its core lies Kimi Delta Attention (KDA), an
expressive linear attention module that extends Gated DeltaNet [111] with a finer-grained gating
mechanism, enabling more effective use of limited finite-state RNN memory. Our bespoke chunkwise
algorithm achieves high hardware efficiency through a specialized variant of the Diagonal-Plus-Low-
Rank (DPLR) transition matrices, which substantially reduces computation compared to the general
DPLR formulation while remaining more consistent with the classical delta rule.

We pretrain a Kimi Linear model with 3B activated parameters and 48B total parameters, based
on a layerwise hybrid of KDA and Multi-Head Latent Attention (MLA). Our experiments show
that with an identical training recipe, Kimi Linear outperforms full MLA with a sizeable margin
across all evaluated tasks, while reducing KV cache usage by up to 75% and achieving up to 6x
decoding throughput for a 1M context. These results demonstrate that Kimi Linear can be a drop-in
replacement for full attention architectures with superior performance and efficiency, including tasks
with longer input and output lengths.

To support further research, we open-source the KDA kernel and vLLM implementations ', and
release the pre-trained and instruction-tuned model checkpoints. *

90

=-«*+-MLA
—e— GDN-H
Kimi Linear 84.3 @                                         =e Kimi Linear

@. MLA 81.3                GDN-H 80.5 @

TPOT (ms)

PW Kimi Linear 51.0

GDN-H 47.9                                                                     -
MLA 47.2                             @ RULER 28k)
¥& MMLU-Pro (4k)
— 50
1x         2x         3x         4x                               4K                           128K 256K 512k 1M
Decoding Acceleration                                                                                               Decoding Length
(a)                                    (b)

(a) Performance vs. acceleration. With strict fair comparisons with 1.4T training tokens, on MMLU-Pro (4k context length,
Kimi Linear leads performance (51.0) at similar speed. On RULER (128k context length, blue circles), it is Pareto-optimal,
top performance (84.3) and 3.98 x acceleration. (b) Time per output token (TPOT) vs. decoding length. Kimi Linear (blue
line) maintains a low TPOT, matching GDN-H and outperforming MLA at long sequences. This enables larger batches, yielding a

6.3x faster TPOT (1.84ms vs. 11.48ms) than MLA at 1M tokens.

'© nttps://github.com/fla-org/flash-linear-attention/tree/main/fla/ops/kda
?@ https: //huggingface.co/moonshotai/Kimi-Linear-48B-A3B-Instruct


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

1 Introduction

As large language models (LLMs) evolve into increasingly capable agents [50], the computational demands of
inference—particularly in long-horizon and reinforcement learning (RL) settings—are becoming a central bottleneck.
This shift toward RL test-time scaling [95, 33, 80, 74, 53], where models must process extended trajectories, tool-use
interactions, and complex decision spaces at inference time, exposes fundamental inefficiencies in standard attention
mechanisms. In particular, the quadratic time complexity and the linearly growing key—value (KV) cache of softmax
attention introduce substantial computational and memory overheads, hindering throughput, context-length scaling, and
real-time interactivity.

Linear attention [48] offers a principled approach to reducing computational complexity but has historically under-
performed softmax attention in language modeling—even for short sequences—due to limited expressivity. Recent
advances have significantly narrowed this gap, primarily through two innovations: gating or decay mechanisms [92, 16,
114] and the delta rule [84, 112, 111, 71]. Together, these developments have pushed linear attention closer to softmax-
level quality on moderate-length sequences. Nevertheless, purely linear structure remain fundamentally constrained by
the finite-state capacity, making long-sequence modeling and in-context retrieval theoretically challenging [104, 4, 45].

Hybrid architectures that combine softmax and linear attention—using a few global-attention layers alongside predomi-
nantly faster linear layers—have thus emerged as a practical compromise between quality and efficiency [57, 100, 66,
12, 32, 81]. However, previous hybrid models often operated at limited scale or lacked comprehensive evaluation across
diverse benchmarks. The core challenge remains: to develop an attention architecture that matches or surpasses full
attention in quality while achieving substantial efficiency gains in both speed and memory—an essential step toward
enabling the next generation of agentic, decoding-heavy LLMs.

In this work, we present Kimi Linear, a hybrid linear attention architecture designed to meet the efficiency demands of
agentic intelligence and test-time scaling without compromising quality. At its core lies Kimi Delta Attention (KDA),
a hardware-efficient linear attention module that extends Gated DeltaNet [111] with a finer-grained gating mechanism.
While GDN, similar to Mamba2 [16], employs a coarse head-wise forget gate, KDA introduces a channel-wise variant
in which each feature dimension maintains an independent forgetting rate, akin to Gated Linear Attention (GLA) [114].
This fine-grained design enables more precise regulation of the finite-state RNN memory, unlocking the potential of
RNN-style models within hybrid architectures.

Crucially, KDA parameterizes its transition dynamics with a specialized variant of the Diagonal-Plus-Low-Rank (DPLR)
matrices [30, 71], enabling a bespoke chunkwise-parallel algorithm that substantially reduces computation relative to
general DPLR formulations while remaining consistent with the classical delta rule.

Kimi Linear interleaves KDA with periodic full attention layers in a uniform 3:1 ratio. This hybrid structure reduces
memory and KV-cache usage by up to 75% during long-sequence generation while preserving global information flow
via the full attention layers. Through matched-scale pretraining and evaluation, we show that Kimi Linear consistently
matches or outperforms strong full-attention baselines across short-context, long-context, and RL-style post-training
tasks—while achieving up to 6x higher decoding throughput at 1M context length.

To facilitate further research, we release open-source KDA kernels with vLLM integration, as well as pre-trained
and instruction-tuned checkpoints. These components are drop-in compatible with existing full-attention pipelines,
requiring no modification to caching or scheduling interfaces, thereby facilitating research on hybrid architectures.

Contributions

* Kimi Delta Attention (KDA): a linear attention mechanism that refines the gated delta rule with improved recurrent
memory management and hardware efficiency.

¢ The Kimi Linear architecture: a hybrid design adopting a 3:1 KDA-to-global attention ratio, reducing memory
footprint while surpassing full-attention quality.

* Fair empirical validation at scale: through 1.4T token training runs, Kimi Linear outperforms full attention and
other baselines in short/long context and RL-style evaluations, with full release of kernels, VLLM integration, and
checkpoints.

2 Preliminary

In this section, we introduce the technical background related to our proposed Kimi Delta Attention.


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

2.1 Notation

In this paper, we define 0, € R® or R®,s. t.,0 € {q,k, v, 0, u, w} denotes a t-th corresponding column vector, and
S,; € R%**4» represents the matrix-form memory state. M and M~ denote lower-triangular masks with and without
diagonal elements, respectively; for convenience, we also write them as Tril and StrictTril.

Chunk-wise Formulation Suppose the sequence is split into L/C' chunks where each chunk is of length C. We
define Oyj € R°*¢ for O € {Q,K, V,O, U, W} are matrices that stack the vectors within the t-th chunk, and
i) = Uec+r is the r-th element of the chunk. Note that t € [0, L/C),r € [1, C]. State matrices are also re-indexed
such that Sty = Sic4;. Additionally, S (c= S a =S 1p i.e., the initial state of a chunk is the last state of the
previous chunk.

Decay Formulation We define the cumulative decay Na J s=    qo F arn and abbreviate Vg” as Vie" Additionally,

Ay o= Ai?  € R©*° is the matrix with elements Ve] / hy: Diag (a) denotes the fine-grained decay, Diag Gay J )  =

IL. _, Diag (a) , and Diy” € RO*4« is the matrix stack from Vg to Vig:

2.2 Linear Attention and the Gated Delta Rule

Linear Attention as Online Learning. Linear attention [48] maintains a matrix-valued recurrent state that accumu-
lates key—value associations:

S; = S¢_1 + kyu; ,     On = S/ at.

From the fast-weight perspective [84, 85], S; serves as an associative memory storing transient mappings from keys to
values. This update can be viewed as performing gradient descent on the unbounded correlation objective

£,(S) = —(S' ki, vt),

which continually reinforces recent key—value pairs without any forgetting. However, such an objective provides no
criterion for which memories to erase, and the accumulated state grows unbounded, leading to interference over long
contexts.

DeltaNet: Online Gradient Descent on Reconstruction Loss. DeltaNet [84] reinterprets this recurrence as online
gradient descent on a reconstruction objective:

L£,(S) = 5\|S' ki — v:|\?.
Taking a gradient step with learning rate 6; gives
S; = Si-1 — BiVsLi(Si-1) = (I— Bi kik! )Si-1 + Bikvv; .

This rule—the classical delta rule—treats S as a learnable associative memory that continually corrects itself toward
the mapping k; +> v;. The rank-1 update structure, equivalent to a generalized Householder transformation, supports
hardware-efficient chunkwise parallelization [1 1, 112].

Gated DeltaNet as Weight Decay. Although DeltaNet stabilizes learning, it still retains outdated associations
indefinitely. Gated DeltaNet (GDN) [111] introduces a scalar forget gate a, € [0, 1], yielding

8, =a,(I- Brkik;) )St-1 + Bikiv, -

Here, a; acts as a form of weight decay on the fast weights [8], implementing a forgetting mechanism analogous to
data-dependent Lz regularization. This simple yet effective modification provides a principled way to control memory
lifespan and mitigate interference, improving both stability and long-context generalization while preserving DeltaNet’s
parallelizable structure.

From this perspective, we observe that GDN can be interpreted as a form of multiplicative positional encoding where
the transition matrix is data-dependent and learnable, relaxing the orthogonality constraint of RoPE [1 15].°

3When the state transformation matrix preserves its orthogonality, absolute positional encodings can also be applied independently
to q and k to be converted into relative positional encodings during the attention computation [87].


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

3 Kimi Delta Attention: Improving Delta Rule with Fine-grained Gating

We propose Kimi Delta Attention (KDA), a new gated linear attention variant that refines GDN’s scalar decay by
introducing a fine-grained diagonalized gate Diag(a,) that enables fine-grained control over memory decay and
positional awareness (as discussed in §6.1). We begin by introducing the chunkwise parallelization of KDA, showing
how a series of rank-1 matrix transformations can be compressed into a dense representation while maintaining stability
under diagonal gating. We then highlight the efficiency gains of KDA over the standard DPLR (Diagonal-Plus-Low-
Rank) formulation [30, 71].

S, = (I- Btktk; ) Diag (a;)Si_-1 + Bykyu, € REX”;      o, = S/ a € R”               (1)

3.1 Hardware-Efficient Chunkwise Algorithm
By partially expanding the recurrence for Eq. | into a chunk-wise formulation, we have:
t                                            r
r                                                                             pT    .       j        i pi    T
Si =  (11 (1-   Bie ie hfe 1) Diag(a,)) Shy t+ 0   I (1-   Be Rey Rly  ) Diag(ary) } - Big hiya
w=1 \j=
——————        ~                            —

(2)

i=1

:=P"                                                                    r
[4]                                                                                 =H)

WY Representation is typically employed to pack a series rank-1 updates into a single compact representation [11].
We follow the formulation of P in Comba [40] to reduce the need for an additional matrix inversion in subsequent
computations.

Piq = Diag (yx)    y Diag(yjq”” ) Rig @ ie)             Hiy = y Diag (viq"  ie)  ") biel]          (3)

w=1        w=1

where the auxiliary vector w; € R@* and u, € R%» are computed via the following recurrence relation:

wiy = Fra (Diver    Swi, (Ki) Diag (74° ie] a)           (4)

i=1
r-1
Ui = Fin (vi — dot (Ki Diag (vi" ‘)a))                                     (5)
i=l

UT transform. We apply the UT transform [46] to reduce non-matmul FLOPs, which is crucial to enable better
hardware utilization during training.

;
My = { I+ Strict Tril { Diag (Sq) (Piy°° © Kia) (=)        Diag (8)          (6)
a

Wig = Muy (Vig OK)         Uy = Mn Viq                                                )

The inverse of a lower triangular matrix can be efficiently computed through an iterative row-wise approach by forward
substitution in Gaussian elimination [28].

Equivalently, in matrix form, we can update the state in chunk-wise:

.            T
Sirti] = Diag (yf) Seq + (vise © Ki)   (Uy — WijS) € Rae X de                   (8)

4


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

(ie) 2

During the output stage, we adopt an inter-block recurrent and intra-block parallel strategy to maximize matrix
multiplication throughput, thereby fully utilizing the computational potential of Tensor Cores.

+
K
13C              :     13C           [t]                        Cxdy
OW = (ri  © Qiu) Siq + Trl  (Ci;  © Qiu) ()    (Uy) — Ww Spy) € RO*       (9)
—_———_S> _’                       t        —_—_$_$_$< $< $_$_E
inter chunk                                                                                                 “pseudo”-value term

intra chunk

i (= @)

[ise

3.2 Efficiency Analysis

64
In terms of representational capacity, KDA aligns with the generalized       RDA ours)                  ?

DPLR formulation, i.e., S; = (D — a:b! )S;_1 + kyv; , both exhibiting
fine-grained decay behavior. However, such fine-grained decay introduces
numerical precision issues during division operations (e.g., the intra-chunk
computation in Eq. 9). To address this, prior work such as GLA [114] per-
forms computations in the logarithmic domain and introduces secondary
chunking in full precision. This approach, however, prevents full utilization
of half-precision matrix multiplications and significantly reduces operator
speed. By binding both variables a and b to k, KDA effectively alleviates        0
this bottleneck—treducing the number of second-level chunk matrix com-

putations from four to two, and further eliminating three additional matrix

multiplications. As a result, the operator efficiency of KDA improves by Figure 2: Execution time of kernels for vary-
roughly 100% compared to the DPLR formulation. A detailed analysis is 1g input lengths, with a uniform batch size

£
oo

32

Execution Time (ms)

2K        4K         8K        16K       32K       64K
Input length

4 The Kimi Linear Model Architecture

The main backbone of our model architecture follows Moonlight [62]. In addition to fine-grained gating, we also
leverage several components to further improve the expressiveness of Kimi Linear. The overall Kimi Linear architecture
is shown in Figure 3.

Neural Parameterization Let x, € IR@ be the t-th token input representation, the input to KDA for each head h is
computed as follows

ge, kh = L2Norm(Swish(ShortConv(W?,,2:))) € R&
v! = Swish(ShortConv(W"2,)) € R®
a = f(WL Wa) € [0, 1)"
Bf = Sigmoid(W42,) € [0, 1]

where d;, d, represent the key and value head dimensions, which are set to 128 for all experiments. For g, k, v, we
apply a ShortConv followed by a Swish activation, following [111]. The g and k representations are further normalized
using L2Norm to ensure eigenvalues stability, as suggested by [112]. The per-channel decay a)’ is parameterized via a
low-rank projection (W< and W? with rank equal to the head dimension) and a decay function f (-) similar to those


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

O Shared Expert
O Routed Expert

Figure 3: Illustration of our Kimi Linear model architecture, which consists of a stack of blocks containing a token mixing layer
followed by a MoE channel-mixing layer. Specifically, we interleave N KDA layers with one MLA layer for token mixing, where N
is set to 3 in our implementation.

used in GDN and Mamba [11 1, 16]. Before the output projection through W, € R?*4, we use a head-wise RMSNorm
[122] and a data-dependent gating mechanism [79] parameterized as:

o, = W. (Sigmoid (W)Wya,) © RMSNorm (KDA (q:, ki, U1, 1, 51)))                  (10)

Here, the output gate adopts a low-rank parameterization similar to the forget gate, to ensure a fair parameter comparison,
while maintaining performance comparable to full-rank gating and alleviating the Attention Sink [79]. The choice of
nonlinear activation function is further discussed in §5.2.

Hybrid model architecture Long-context retrieval remains the primary bottleneck for pure linear attention, we
therefore hybridize KDA with a small number of full global-attention (Full MLA) layers [19]. For Kimi Linear, we
chose a layerwise approach (alternating entire layers) over a headwise one (mixing heads within layers) for its superior
infrastructure simplicity and training stability. Empirically, a uniform 3:1 ratio, i.e., repeating 3 KDA layers to 1| full
MLA layer, provided the best quality—throughput trade-off. We discuss other hybridization strategies in § 7.2.

No Position Encoding (NoPE) for MLA Layers. In Kimi Linear, we apply NoPE to all full attention (MLA) layers.
This design delegates the entire responsibility for encoding positional information and recency bias (see § 6.1) to the
KDA layers. KDA is thus established as the primary position-aware operator, fulfilling a role analogous to, or arguably
stronger than, auxiliary components like short convolutions [3] or SWA [76]. Our findings align with prior results
[1 10, 7, 19], who similarly demonstrated that complementing global NoPE attention with a dedicated position-aware
mechanism yields competitive long-context performance.


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

100 —*

75      *

~
wn

Accuracy (%)
wn
S

Accuracy (%)
wn
S

25              ‘                —*— KDA                    25               .                                               25                           \
\            = *- GDN                                 \                                                                   ‘
\            = » = Mamba2                               ‘\                                                                   ‘
0                  4            ~            -                   0                  +            +            +                   0                               4            +
256             512            1024           2048                                256             512            1024           2048                                256             512            1024           2048
Sequence length                                              Sequence length                                              Sequence length
100                                  $= i                  100                        OO
Ad

*                                                                             *
~~                                                                  75                                           7
we                                                                                                                 ’
YH
Pa                                                                                                               a
3                                                                   50                                         1
5                                                                                                             #
[sy                                                                                                            ’
<                                        —e— KDA                     25                                      x

= *- GDN                                                 ”

=» = Mamba2                                            :

te» 9 9 5   Qe ee Lee ee Ht    -—— —- —- —_- —_- _____-__-
5K       10K 15K 20K                             5K       10K 15K 20K                             5K       10K 15K 20K
Training steps                                            Training steps                                            Training steps
(a) Palindrome                                     (b) MQAR                                        (c) Stack

Figure 4: Results on synthetic tasks: palindrome, multi query associative recall, and the state tracking.

We note that NoPE offers practical advantages, particularly for MLA. First, NoPE enables their conversion to the
highly-efficient pure Multi-Query Attention (MQA) during inference. Second, it simplifies long-context training, as it
obviates the need for RoPE parameter adjustments, such as frequency base tuning or methods like YaRN [72].

5 Experiments

5.1 Synthetic tests

We start by evaluating KDA against other competing linear attention methods on three synthetic tasks, serving as
benchmark tests for long-context performance. Across all experiments, we adopt a consistent model configuration of
2 layers with 2 attention heads, each having a head dimension of 128. For each task, we train the model for at most
20,000 steps with a grid search over learning rates in {5 x 10~°, 1 x 10-4,5 x 10-4, 1 x 1073}. We then present the
best-performing training accuracy curves. Specifically, we compare two scenarios: (1) the performance of different
tasks as training length increases from 256 to 2,048 tokens, measuring the peak accuracy; and (2) the convergence
speed of KDA, GDN, and Mamba? with a fixed context length of 1,024 tokens.

Palindrome Palindrome requires the model to reproduce a given sequence of random tokens in reverse order. As
illustrated in Table 5.1, given an input like “O GR S UN E”, the model must generate its exact reversal. Such copying

tasks are known to be difficult for linear attention models [45], as they struggle to precisely retrieve the entire history
from a compressed, fixed-size memory state.

Input O GR S U N E                EN U S R GO
Output ¢ ¢ ¢ ¢ ¢ @ ©       @       N U S R GO @
Multi Query Associative Recall (MQAR) MQAR assesses the model’s ability to retrieve values associated with

multiple queries that appear at various positions within the context. For instance, as shown in Table 5.1, the model

is asked to recall 0 for the query B and 5 for G. This task is known to be highly correlated with language modeling
performance [5].

Input A 1 C 3 B 0 M 8 G 5 E 4
Output ¢ ¢ 6 6 9 6 6 6 6 6 @ 6 G6 DS


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Table 1: Ablation study on the hybrid ratio of KDA to MLA attention and other key components. We list the training and validation
perplexities (lower is better) for comparison. The best-performing model, used in our final experiments, is highlighted in gray.

Training PPL (,)      Validation PPL (1)

3:1               9.23                         5.65

0:1               9.45                         5.77

Hybrid ratio          1:1                 9.29                           5.66
TA               9.23                         5.70

15:1                        9.34                                       5.82

w/o output gate             9.25                      5.67

w/ swish output gate              9.43                        5.81
w/o convolution layer              9.29                        5.70

Stack We assess the state tracking capabilities [27] of each candidate by simulating the standard LIFO (Last In First
Out) stack operations. Our setup involves 64 independent stacks, each identified by a unique ID. The model processes a
sequence of two operations: 1) PUSH: an action like “<PuUSH> | G” adds the element G to stack 1; 2) POP: an action
like “<pop> 0 E” requires the model to predict the element E most recently pushed onto stack 0. The objective is to
accurately track the states of all stacks and predict the correct element upon each pop request.

Figure 4 shows the final results. Across all tasks, KDA consistently achieves the highest accuracy as the sequence
length increases from 256 to 2,048 tokens. In particular, on the Palindrome and recall-intensive MQAR tasks, KDA
converges significantly faster than GDN. This confirms the benefits of our fine-grained decay, which enables the model
to selectively forget irrelevant information while preserving crucial memories more precisely. We also observe that
Mamba? [16], a typical linear attention that uses only multiplicative decay and lacks a delta rule, fails on all tasks in our
model settings.

5.2 Ablation on Key Components of Kimi Linear

We conducted a series of ablation studies by directly comparing different models to the first-scale scaling law model, i.e.,
16 heads, 16 layers. All models were trained with the same FLOPs budget and hyperparameters for a fair comparison.
We report the training and validation perplexities (PPLs) in Table |. The validation PPL is calculated on a high-
quality dataset whose distribution differs significantly from the pre-training corpus, emphasizing generalization under
distribution shift, and thus the differences in training and validation perplexities.

Output gate We compare our default Sigmoid output gate against two variants: one with no gating and another with
swish gating. The results show that removing the gate degrades performance. Moreover, the swish gate adopted by
[111] performs substantially worse than Sigmoid. Our observation is consistent with [79], who also conclude that
Sigmoid gating offers superior performance. So we adopt Sigmoid across all of our experiments, including GDN-H.

Convolution Layer Lightweight depthwise convolutions with a small kernel size (e.g., 4) can be effective at capturing
local token dependencies [3] and are widely adopted by many recent architectures [16, 5, 112]. We validate its efficacy
in Table |, demonstrating that convolutional layers continue to play a non-negligible role in hybrid models.

Hybrid ratio We performed an ablation study to determine the optimal hybrid ratio of KDA linear attention layers to
MLA full attention layers. Among the configurations tested, the 3:1 ratio (3 KDA layers for every 1 MLA layer) yielded
the best results, achieving the lowest training and validation losses. We observed clear trade-offs with other ratios: a
higher ratio (e.g., 7:1) produced a comparable training loss but led to significantly worse validation performance, while
a lower ratio (e.g., 1:1) maintained a similar validation loss but at the cost of increased inference overhead. Furthermore,
the pure full-attention baseline (0:1) performed poorly. Thus, the 3:1 configuration offers the most effective balance
between model performance and computational efficiency.

NoPE vs. RoPE As shown in Table 5, the Kimi Linear consistently excels on long-context evaluations, whereas Kimi
Linear (RoPE) attains similar scores on short-context tasks. We posit that this divergence arises from how positional
bias is distributed across depth. In Kimi Linear (RoPE), the global attention layer carries a strong, explicit relative
positional signal, while the linear attention (e.g., GDN) contributes a weaker, implicit positional inductive bias. This
mismatch yields an overemphasis on short-range order in the global layer, which benefits short contexts but makes
the model less flexible when adapting mid-training to extended contexts. By contrast, Kimi Linear induces a more


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture

Table 2: Model configurations and hyperparameters for scaling law experiments.

# Act. Params." Head Layer Hidden Tokens            Ir           batch size?
653M         16      16      1216      38.8B 2.006 x 107%      336
878M         18      18      1376      59.8B 1.790 x 107?      432
1.1B          20      20      1536      85.2B 1.617 x 10-%       512
1.4B         22      22      1632     102.5B 1.486 x 107%      576
1.7B         24      24      1776     128.0B 1.371 x 107%      640

TECHNICAL REPORT

T Denotes the number of activated parameters in our MoE models, excluding embeddings.
¥ All models were trained with a context length of 4,096.

—~
er                === MLA: 2.3092 x C~9:0986
.  as             === Kimi Linear: 2.2879 x C~°:0527
eS,
Sy ‘“
2.2      soe,                             |
s  s
s  “
s  s
sJ s,
Soe,
s
-                       Ss. 1.16
°                        s
A 21}                  >.              |
Se
re s
ba *
Suis
wees,
. x
s x
}—                                   »     |
2.0                                     Sos
KY
x
| |
10"

PFLOP/s-days

Figure 5: The fitted scaling law curves for MLA and Kimi Linear.

balanced positional bias across layers, which improves robustness and extrapolation at long ranges, leading to stronger
long-context performance. Regarding long context performance, as shown in Table 5, Kimi Linear achieves the best
average score across different long context benchmarks, which verifies the benefits we claim in the last section.

5.3. Scaling Law of Kimi Linear

We conducted scaling law experiments on a series of MoE models following the Moonlight [62] architecture. In all
experiments, we activated 8 out of 64 experts and utilized the Muon optimizer [62]. Details and hyperparameters are
listed in Table 2.

For MLA, following the Chinchilla scaling law methodology [37], we trained five language models of different sizes,
carefully tuning their hyperparameters through grid search to ensure optimal performance for each model. For KDA,
we maintained the best hybrid ratio of 3:1 as ablated in Table |. Except for this, we adhered strictly to the MLA
training configuration without any modifications. As shown in Figure 5, Kimi Linear achieves ~ 1.16 computational
efficiency compared to the MLA baselines with compute optimal training. We expect that careful hyperparameter
tuning will yield superior scaling curves for KDA.

5.4 Experimental Setup

Kimi Linear and baselines settings We evaluate our Kimi Linear model against a full-attention MLA baseline and a
hybrid Gated DeltaNet (GDN-H) baseline, all of which share the same architecture, parameter count, and training setup
for fair comparisons. The model configuration is largely aligned with Moonlight [62], with the key distinction that
MoE sparsity is increased to 32. Each model activates 8 out of 256 experts, including one shared expert, resulting in
48 billion total parameters and 3 billion active parameters per forward pass. The first layer is implemented as a dense
layer without MoE, ensuring stable training. To evaluate the effectiveness of NoPE in Kimi Linear, we also introduce a
hybrid KDA baseline using RoPE with the same model configuration, referred to as Kimi Linear (RoPE).


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Evaluation Benchmarks Our evaluation encompasses three primary categories of benchmarks, each designed to
assess distinct capabilities of the model:

* Language Understanding and Reasoning: Hellaswag [121], ARC-Challenge [14], Winogrande [83], MMLU [36],
TriviaQA [47], MMLU-Redux [26], MMLU-Pro [103], GPQA-Diamond [82], BBH [94], and [105].

* Code Generation: LiveCodeBench v6 *[44], EvalPlus [60].
¢ Math & Reasoning: AIME 2025, MATH 500, HMMT 2025, PolyMath-en.

* Long-context: MRCR ° , RULER [38], Frames [52], HELMET-ICL [118], RepoQA [61], Long Code Arena [13]
and LongBench v2 [6].

¢ Chinese Language Understanding and Reasoning: C-Eval [43], and CMMLU [55].

Evaluation Configurations All models are evaluated using temperature 1.0. For benchmarks with high variance,
we report the score of Avg@k. For base model, We employ perplexity-based evaluation for MMLU, MMLU-Redux,
GPQA-Diamond, and C-Eval. Otherwise, generation-based evaluation is adopted. To mitigate the high variance inherent
to GPQA-Diamond, we report the mean score across eight independent runs. All evaluations are conducted using our
internal framework derived from LM-Harness-Evaluation [10], ensuring consistent settings across all models.

5.4.1 Pre-training recipe

Pre-training recipe All models are pretrained using a 4,096-token context window, the MuonClip optimizer, and the
WSD learning rate schedule, processing a shared total of 1.4 trillion tokens sampled from the K2 pretraining corpus
[50]. The learning rate is set to 1.1 x 10~3, and the global batch size is fixed at 32 million tokens. They also adopt the
same annealing schedule and long-context activation phase established in Kimi K2 [50].

Our final released Kimi Linear checkpoint is pretrained using the same procedure, but with an expanded total of 5.7
trillion tokens to match the pretraining tokens of Moonlight. In addition, the final checkpoint supports a context length
of up to | million tokens. We compare the performance of Kimi Linear@5.7T and Moonlight in Appendix D

5.4.2 Post-training recipe

SFT recipe The SFT dataset extends the Kimi K2 [50] SFT data by incorporating additional reasoning tasks, creating
a large-scale instruction-tuning dataset that spans diverse domains with a heavy emphasis on math and coding. We
employ a multi-stage SFT approach, initially training the model on a broad range of diverse SFT data for general
instruction-following, followed by scheduled targeted training on reasoning-intensive data to enhance the model’s
reasoning capabilities.

RL recipe For the RL training prompt set, we primarily integrate three data sources: mathematics, code, and STEM.
The main purpose of this enhancement is to boost the model’s reasoning ability. Before conducting RL, we pre-selected
data that matches a moderate difficulty level for the starting checkpoint.

A known risk of RL training is the potential degeneration of general capabilities. To mitigate this, we incorporate
the PTX loss [70] during RL, following the practice of K2 [50]. This involves concurrent SFT on a high-quality,
distributionally diverse dataset in the RL progress. Our PTX dataset spans both reasoning and general-purpose tasks.
All data mentioned above are subsets derived from the training recipe of the K2 model [50].

For the RL algorithm, we use the same algorithm as in K1.5 [95], while introducing several advanced tricks. We noticed
that the precision mismatch between training and inference engines may lead to unstable RL learning. Therefore we
introduce truncated importance sampling, a method that effectively mitigates the policy mismatch between rollout and
training [116]. We also dynamically adjust the KL penalty and the mini batch size (i.e., the number of updates per
iteration) to make the RL training stable and avoid collapse of entropy [15].

5.5 Main results

5.5.1 Kimi Linear@1.4T results

Pretrain results © We compared our Kimi Linear model against two baselines (MLA and hybrid GDN-H) using a 1.4T
pretraining corpus in Table 3. The evaluation focused on three areas: general knowledge, reasoning (math and code),
and Chinese tasks. Kimi Linear consistently outperformed both baselines across almost all categories.

‘Questions from 2024.8 to 2025.5
Shttps: //huggingface.co/datasets/openai/mrcr

10


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

¢ General Knowledge: Kimi Linear scores highest on all of the key benchmarks like BBH, MMLU and HellaSwag.

¢ Reasoning: It leads in math (GSM8K) and most code tasks (CRUXEval). However, it scores slightly lower on
EvalPlus compared to GDN-H.

¢ Chinese Tasks: Kimi Linear achieves the top scores on CEval and CMMLU.

In summary, Kimi Linear demonstrated the strongest performance, positioning it as a strong alternative to full-attention
architectures at short context pretraining.

Table 3: Performance comparison of Kimi Linear with the full-attention MLA baseline and the hybrid GDN baseline, all after the
same pretraining recipe. Kimi Linear consistently outperforms both MLA and GDN-H on short-context pretrain evaluations. Best
per-column results are bolded.

Type Base                            MLA              GDN-H              Kimi Linear
Trained Tokens                     1.4T                    1.4T                           1.4T
HellaSwag             81.7        82.2           82.9
ARC-challenge                     64.6                    66.5                           67.3
Winogrande                            78.1                    771.9                           78.6
General      BBH                   71.6         70.6            72.9
MMLU               71.6        72.2           73.8
MMLU-Pro                            47.2                    47.9                           51.0
TriviaQA             68.9        70.1           71.7
GSM8K              83.7        81.7           83.9
MATH                                       54.7                    54.1                           54.7
Math & Code            EvalPlus                             59.5                63.1                      60.2
CRUXEval-I-cot                  51.6                    56.0                           56.6
CRUXEval-O-cot                61.5                    58.1                           62.0
Chinese      CEval                79.3        79.1           79.5
CMMLU              79.5        80.7           80.8

Table 4: Performance comparison of Kimi Linear with the full-attention MLA baseline and the hybrid GDN baseline, all using the
same SFT recipe after pretraining. Kimi Linear consistently outperforms both MLA and GDN-H on short-context instruction-tuned
benchmarks. Best per-column results are bolded.

Type Instruct                             MLA       GDN-H       Kimi Linear
Trained Tokens                           1.4T          1.4T               1.4T
BBH                         68.2      68.5         69.4
MMLU                                              75.7             75.6                  77.0
G          /        MMLU-Pro                                      65.7             64.8                  67.4
enera’” ~~ MMLU-Redux                                 79.2             78.7                  80.3
GPQA-Diamond (Avg @8)              57.1             58.6                  62.1
LiveBench (Pass @ 1)            45.7       46.4          45.2
AIME 2025 (Avg @64)                     20.6             21.1                    21.3
MATHS00 (Acc.)                             80.8             83.0                  81.2
HMMT 2025 (Avg @32)                 11.3            11.3                  12.5
Math & Code boy Math-en (Avg @4)              413        415            43.6
LiveCodeBench v6 (Pass@ 1)         25.1            25.4                 26.0
EvalPlus                                                        62.6                62.5                        61.0

SFT results Kimi Linear demonstrates strong performance across both general and math & code tasks after undergoing
the same supervised fine-tuning (SFT) recipe, consistently outperforming MLA and GDN-H. In general tasks, Kimi
Linear leads across the board, achieving the top scores on various MMLU benchmarks, BBH, and GPQA-Diamond. In
math & code tasks, it surpasses both baselines on difficult benchmarks like AIME 2025, HMMT 2025, PolyMath-en, and
LiveCodeBench. Despite some minor exceptions like MATH500 and EvalPlus, Kimi Linear shows robust superiority
across the tasks, confirming its clear superiority to the other models tested (GDN-H and MLA).

11


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Table 5: Comparisons of Kimi Linear with MLA, GDN-H, and Kimi Linear (RoPE) across long-context benchmarks. The last
column reports the overall average (¢). All models is trained on 1.4T tokens. Best per-column results are bolded.

Long Code Arena

RULER MRCR  HELMET-ICL  LongBench V2 Frames RepoQA                                                   Avg.
Lib          Commit
MLA                  81.3      22.6         88.0             36.1          60.5       63.0     32.8      33.2      52.2
GDN-H                80.5      23.9         85.5             32.6          58.7       63.0     34.7      30.5      51.2
Kimi Linear (RoPE)     78.8      22.0         88.0             35.4          59.9       66.5      31.3      32.5      51.8
Kimi Linear                            84.3              29.6                     90.0                             35.0                      58.8                68.5            37.1             32.7              54.5
65                                                                                          94                                                                                          25
-* »MLA@L4T                              -*»MLA@L4T                              =* »MLA@L4T
—e— Kimi Linear@1.4T                                                  —e— Kimi Linear@1.4T                                                  —e Kimi Linear@1.4T

Accuracy
Accuracy
Accuracy

20         40         60         80         100                       70            20         40         60         80         100                                      20         40         60         80         100

Train                                                                    MATH 500 Test                                                                AIME 2025
(a)                                                        (b)                                                        (c)

Figure 6: The training and test accuracy curves for Kimi Linear@1.4T and MLA@1.4T during Math RL training. Kimi Linear
consistently outperforms the full attention baseline by a sizable margin during the whole RL process.

Long Context Performance Evaluation We evaluate the long-context performance of Kimi Linear against three
baseline models—MLA, GDN-H, and Kimi Linear (RoPE)—across several benchmarks at 128k context length (see
Table 5). The results highlight Kimi Linear’s clear superiority in these long-context tasks. It consistently outperformed
MLA and GDN-H, achieving the highest scores on RULER (84.3) and RepoQA (68.5) by a significant margin. This
pattern of outperformance held across most other tasks, except for LongBench V2 and Frames. Overall, Kimi Linear
achieved the highest average score (54.5), further reinforcing its effectiveness as a leading attention architecture in
long-context scenarios.

RL results To compare the RL convergence properties of Kimi Linear and MLA, we conduct RLVR using the
in-house mathematics training set from [50], and evaluate on mathematics test sets (e.g., AIME 2025, MATHS00),
while keeping the algorithm and all hyperparameters identical to ensure a fair comparison of performance.

As shown in Figure 6, Kimi Linear demonstrates better efficiency compared to MLA. On the training set, even though
both models start at similar points, the growth rate of training accuracy for Kimi Linear is significantly higher than that
of MLA, and the gap gradually widens. On the test set, similar phenomena are observed. For example, on MATHS00
and AIME2025, Kimi Linear achieves faster and better improvement compared to MLA. Overall, in reasoning-intensive
long-form generation under RL, we empirically observe that Kimi Linear performs significantly better than MLA.

Summary of overall findings During the pretraining and SFT stages, a clear performance hierarchy was established:
Kimi Linear outperformed GDN-H, which in turn outperformed MLA. However, this hierarchy shifted in long-context
evaluations. While Kimi Linear maintained its top position, GDN-H’s performance declined, placing it behind MLA.
Furthermore, in the RL stage, Kimi Linear also demonstrated superior performance over MLA. Overall, Kimi Linear
consistently ranked as the top performer across all stages, establishing itself as a superior alternative to full attention
architectures.

5.6 Efficiency Comparison

Prefilling & Decoding speed We compare the training and decoding times for full attention MLA [19], GDN-H, and
Kimi Linear in Figure 7a and Figure 7b. Note that all models are based on the Kimi Linear 48B setting, with the same
number of layers and attention heads. We observe that: 1) Despite incorporating a more fine-grained decay mechanism,
Kimi Linear introduces negligible latency overhead compared to GDN-H during prefilling. As shown in Figure 7a, their

12


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

=-*-+MLA                                                                                             -*-MLA
—e— GDN-H                                                                                                —e— GDN-H
60 | —-e Kimi Linear                                                                                  —e— Kimi Linear                                                            t

a
o

Latency (s)
TPOT (ms)

N
S

4K               128K 256K 512K 1M        4K               128K 256K 512K 1M
Prefilling Length                                                                                    Decoding Length

(a)                                                                           (b)

Figure 7: (a) The prefilling time of MLA (full attention), hybrid GDN-H and our Kimi Linear. (b) The time per output token (TPOT)
for MLA, GDN-H and Kimi Linear during decoding. (We use batch size = | here for tests.)

performance curves are virtually indistinguishable, confirming that our method maintains high efficiency. The hybrid
Kimi Linear model demonstrates a clear efficiency advantage over the MLA baseline as sequence length increases.
While its performance is comparable to MLA at shorter lengths (4k—16k), it becomes significantly faster from 128k
onwards. This efficiency gap widens dramatically at scale, with Kimi Linear outperforming MLA by a factor of 2.3
for 512k sequences and 2.9 for 1M sequences. As shown in Figure 1b, Kimi Linear fully demonstrates its advantages
during the decoding phase. For decoding at 1M context length, Kimi Linear is 6x faster than full attention.

6 Discussions

6.1 Kimi Delta Attention as learnable position embeddings

The standard attention in transformers is by design agnostic to the sequence order of its inputs [99], thus necessitating
explicit positional encodings [75, 86]. Among various methods, RoPE [88] has emerged as the de facto standard in
modern LLMs due to its effectiveness [98, 1, 19]. The mechanism of multiplicative positional encodings like RoPE can
be analyzed through a generalized attention formulation:

t
si=ai | [] Ry | &              (11)
j=i4+l1

where the position relationship between the t-th query q; and the 7-th key k; is reflected by the cumulative matrix
products. RoPE defines the transformation matrix R,; as a block diagonal matrix composed of d;/2 2D rotation

matrices RE = (3005 meray ) with per-2-dimensional angular frequency 6;,. Due to the properties of rotation

matrices, i.e., Ry_; = R/ Ri, absolute positional information R; and R; can be applied separately to q,; and k;, which

cos((t—7)0;) — sin((t—1)0;) )

are then transformed into relative positional information ¢ — 7 encoded as =i 41, Rj =  ( sin((t—i)0,) cos((t—i) Ox)

Consequently, we show that linear attentions with the gated delta rule can be expressed in a comparable formulation in
Eq. 12. Similar forms for other attention variants are summarized in Table 6.

t

t
o= >> (al { [] As (f- 6)hjk]) | ey | 2,          (12)

i=l            j=itl

From this perspective, GDN can be interpreted as a form of multiplicative positional encoding whose transition matrix
is data-dependent, thereby relaxing the orthogonality constraint imposed by RoPE and can be potentially more powerful
[115]. ° This provides a potential solution to the known extrapolation issues of RoPE, whose fixed frequencies can cause
overfitting to context lengths seen during training [108, 72]. Some recent works adopt workarounds like partial RoPE

®When preserving orthogonality, absolute positional encodings can be applied independently to q and k, which are then
automatically transformed into relative positional encodings during the attention computation [87].

13


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Table 6: An overview of attention mechanisms in their mathematically equivalent recurrent (o;) and parallel (O) forms. We omitted
the normalization term and {; to achieve a more concise representation. The function ¢ refers to the infinite-dimensional feature
space corresponding to the exponential kernel, i.e., ¢(q) '@(k) = exp(q'k).

Recurrent form                                                            Parallel form
t
SA [99] > exp (qi ky) vy                                       (exp (QK') ©M) V
j=l
SA +RoPE [88] > exp («°(  ll  n.) i) v;                        (exp (R(Q)R(K)") } M) Vv
j=l             s=jt+l
t
LA[ION YS (ae ky) &;                                            (Qk @M)V
j=l
Mamba? [16   s («°(  ll  «) i) v;                           (QK'OAOM)V
j=l        s=j+l
t            t
GLA[II4] Sofa! { II Diae(o.) ‘) v;           ((Qor)(K)'eM)v
j=l        s=jt+l
DeltaNet [84] So (af         (I- ix!)) i) v;                       (QK' ®M) (I+KK'O©M-) Vv
j=l        s=jtl
Fox [58 exp (qi k;) (  ll   «) Vv;                              (exp (QK') OAO M) Vv
j=l                s=j+1
DeltaFormer [125  (+a    ll    I- ¢(ks)@ ww") o(k;) |v; (exp(QK") ©M) (I+exp(WK') ©M7-)'V
j=l             s=j+1
PaTH-FoX [115] 5 exp (2    Tl (@- wt!)  (  Tl  «) vj (exp ((QK™ OM) (I+ WW" OM) ')©AOM)V
j=l             s=jtl                        s=jt+l
GDN [111  s  a   ll Qs (r-!) ey) v;           (QK'®AOM) (1+ KK'OAOM-) 'V
j=l        s=jtl
Comba [40  a  ll  (as hk!) ts) v;            (QK'® AGM) (I+ KK™ 940 oM-) Vv
j=l        s=j+l
ste     _              -1
Rwkv7 711 Sal   (Diag (as) — (0. © kes) k)) i) v;   ((Q or) (*)'o M) (1 + (K oT  ) (28) © mM)   Vv
j=l        s=jt+l
é      T     i                         T                                   kK)!                          Ky)!        1)!
KDA (ours) So (ai { [] Diag (ax) (I— koko) ) k; ) 0)        ((Qor)(§)' OM) (1+ (Kor) (K)"OM"') Vv
j=l        s=j+1

[7] or even forgo explicit positional encodings entirely (NoPE) [49, 76, 19]. Given that GDN serves as an analogue role
to RoPE, we choose NoPE for global full attention layers (MLA) in our model, allowing positional information to be
captured dynamically by our proposed KDA model.

Moreover, a key strength of RoPE is its fine-grained positional encoding, achieved by assigning different rotation
frequencies to each pair of dimensions, which functions analogously to a Nonuniform Fourier Transform [7, 41] along
the feature dimension. Standard GDN, however, employs a per-head scalar decay and lacks this per-dimensional
diversity, which motivates us to propose KDA with a learnable channel-wise gate.

6.2 Relation to DPLR

(Gated) DeltaNet can be generalized to a more expressive Diagonal-Plus-Low-Rank (DPLR) structure, defined as
D — a,b; . This structure was also explored in models such as S4 [30], which employed a static DPLR formulation as
the state transition matrix. During computation, this matrix is typically jointly diagonalized into the complex plane,
thereby restricting its expressiveness to diagonal transformations [64].

While the DPLR structure introduces richer model interactions and can potentially enhance recall through its key—value
update rule, it also suffers from a notable limitation: high computational cost and poor parallelizability. These drawbacks
make DPLR inherently slower in large-scale or real-time scenarios, where maintaining parameter efficiency becomes a
crucial design challenge.

To address this issue, KDA introduces a constrained variant of DPLR, where Eq. | can be rewritten as S; =
(Diag(a) - Brkik; Diag(ar)) S:_1 + 6:k+v,' with the correspondence between the two given by:

Ss; =(D- ab) )S4-1 + kyv, , s.t., D = Diag(a,), ay = Bk, by = ky O cy.

Furthermore, by sharing a;, we can factor it out as in Eq. 1, enabling a fine-grained multiplicative decay over S; ina
manner similar to GLA [114], followed by a Householder-style transformation like DeltaNet [84, 112] for efficient

14


===== PAGE BREAK =====

1

ANOORWNRFRO

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

def chunk_dplr(q, k, v, a, b, g, chunk_size):              idef chunk_kda(q, k, v, a, b, g, chunk_size):
B, H, T, K, V, BT = *q.shape, v.shape[-1], chunk_size     2   B, H, T, K, V, BT = *q.shape, v.shape[-1], chunk_size
NT, S = T // BT, k.new_zeros(B, H, K, V)              3   NT, S = T // BT, k.new_zeros(B, H, K, V)
q, k, v, a, b, g = map(lambda x: rearrange(x, 'b h (n c)   4   q, k, v, g = map(lambda x: rearrange(x, 'bh (nc) ...
+ d->bhnc d', c=BT), [q, k, v, a, b, gl)           + ->bhnc...', c=BT), [q, k, v, g])
gc = g.cumsum(-2)                                   5    gc = g.cumsum(-2)
-  Aab, Aak, Aqb, Aqk = (torch.zeros(B, H, NT, BT, BT) for   6+ Aqk, Akk = (torch.zeros(B, H, NT, BT, BT) for _ in
<> _ in range(4))                                    ~~ range(2))
7
for i in range(BT):                                 8    for i in range(BT):
a_i, q_i, g_i = (x[:,:,:,i,None] for x in (a, q,      9      k_i, q_i = k[:, :, :, i, None], q[:, :, :, i, None]
~~ gce))                                       0)       gi = gc[...,i:iti,:]
mask = (torch.arange(BT) <= i)[..., None]            1       mask = (torch.arange(BT) <= i)[..., None]
si_i = (g_i - gc).exp().where(mask, 0)             2      si_i = (g_i - gc).exp().where(mask, 0)
s2_i= (g_i - gl:,:,:,i,None] - gc).where(mask, 0)     3      s2_i = (gc - g_i).exp()
=     Agk[..., i, :] = (q_i * k * s1_i).sum(-1)           4+     Aqk[:, :, :, i, :] = (q_i * k * s1_i).sum(-1)
=     Aqb[..., i, :] = (q_i * b * s1_i).sum(-1)           5+     Akk[..., i] = (kK_i * k * s2_i).sum(-1)
-     Aab[..., i, :] = (a_i * b * s2_i).sum(-1)            6   mask = torch.triu(torch.ones(BT, BT), diagonal=0)
-     Aak[..., i, :] = (a_i * k * s2_i).sum(-1)           7   A = -Akk.masked_fill(mask, 0)
for i in range(1, BT):                             8    for i in range(1, BT):
Aab[..., i, :i] = Aab[..., i, :i] + (Aabl..., i, :,   9     A[..., i, :i] = AL..., i, :i] + (AL..., i, :, None]
<>» None] * Aab[..., :, :i]).sum(-2)                       oo * A[..., :, :i].clone()).sum(-2)
Aab = Aab + torch.eye(BT)                            20    A = (A + torch.eye(BT))
u, w= Aab @ (Aak @ v), Aab © ((gc-g).exp(Q) * a)         21    w, u=A © (gc.expQ * k), AQv
o = torch.zeros_like(v)                              22    o = torch.zeros_like(v)
mask = torch.triu(torch.ones(BT, BT), diagonal=1)        23    mask = torch.triu(torch.ones(BT, BT), diagonal=1)
for i in range(0, NT):                             24    for i in range(0, NT):
q_i, k_i, v_i, u_i, w_i, b_i = (x[:, :, i] for x in   25      q_i, k_i, u_i, g_i, wi = (x[:, :, i] for x in (q, k,
~ (q, k, v, u, w, b))                              > u, ge, w))
-      o1 = Aqk[:, :, i] @ vii                          26+      o[:,:,i]=(q_i *g_i.exp()) @ S + Aqk @(u_i-w_i © S)
-      02 = Aqb[:, :, i] © (u_i + w_i © S)                27       decay = (g_il:,:,-1:] - g_i).expQ
-      03 = (q_i * gkcl[:, :, i].expQ) @S               28       S=S * gil:, :, -1, :, None] .exp(Q
o[:, :, i] = o1 + 02 + 03                       29+      S += (k_i * decay).transpose(-1,-2) @ vii
decay = (gc[:, :, i, -1, None] - gcl[:, :, i]).exp()   30   return o, S
S = S * gcl:,:,i,-1,:,None] .exp()
-      S +=(k_i * decay).transpose(-1,-2) @ v_i
-      S +=(b_i * decay).transpose(-1,-2) @ (u_i + w_i @ S$)        (b) PyTorch-style pseudo code for chunkwise KDA.
return o, §

(a) PyTorch-style pseudo code for chunkwise DPLR.

state updating. We provide a side-by-side comparison of the chunkwise PyTorch-style pseudocode implementations for
DPLR and KDA in Listing 8a and Listing 8b.The key improvements are highlighted below:

* Listing 8a Line 13-16 vs., Listing 8b Line 14-15 : the reciprocal of the cumulative decay term 1/T in chunkwise
form (Eq. 9) can introduce numerical instability. While we can resolve this issue by secondary chunking [1 13], it
incurs additional computation and I/O overhead. By fixing a = b = k in the DPLR formulation, KDA removes the
need for two secondary chunking steps, substantially reducing redundant operations and improving overall efficiency.

¢ Listing 8a Line 25-27,31-32 vs., Listing 8b Line 26,29 : KDA further eliminates roughly three matrix multiplica-
tions during inter-chunk and output computation, leading to significant kernel-level acceleration.

We further benchmark the kernel speed in Fig. 2, showing that KDA achieves nearly 2x the speed of DPLR for sequence
lengths up to 64k.

6.3 Complexity Analysis

Training flops We maintain a similar number of parameters in Kimi Linear as in the full attention MLA. The linear
projection calculation remains identical to that of the global attention layer. The key distinction lies in the FLOPs
associated with attention computation. For simplicity, we focus on non-variable length scenarios. Based on the
implementation of the gated rule kernel, the theoretical FLOPs for a single attention head with headdim dp, and a fixed
chunk size C' = 64 in the gated delta rule [102] (per sequence of length T) are as follows:

FLOPsxpa(T; C, dn) = 6Td?. + 3TCdp + TC?.                                 (13)
For full (global) attention, the dominant term per head is
FLOPsatm(T;dn) = 2T7dp.                                               (14)

Inference strategy and cost The inference strategy in Kimi Linear employs a hybrid approach to optimize both
computational and I/O efficiency. During the prefill phase, the model utilizes a FLOP-intensive chunk kernel (see

15


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Table 7: An overview of different attention mechanisms through the lens of state updating rules and their learning objective under the
TTT framework [90]. We ignore all normalizer terms and activation/kernel functions for brevity.

Objective £                                                   Update rule S: = S:-1 — Vs,_,£
LA [48          — (Si iki, v:)                                               S; = Si-1 + kev!
RetNet [92           — Br (Si-ake, ve) + 4 ||VT— 0 Se-allé,                       S; = 08:1 + Bekvv?
Mamba? [16          — Be (Si_ake, ve) + 3 || VI — arSral),                      Si = crSi-1 + Beko?
GLA [114          ~ (Spyker) +4 | estas]                S, = Diag(a,)Sy_1 + kw?
HGRN2 [77          (S1,(1—a,),m) +4 | VDiag T— a1)8.-|        S, = Diag(as)S1_1 + (1 — av)
Longhorn [59          $ |e — SE Fell aecae                                     S.= (I - fie hikt) Si-1 + Bike}
Comba [40          & |lv, — ST ike||” + 3 |] VI — a Seal,                    S,= (a: — Bulkrke!) Sia + Bikews
RWKV7 [71       3 jee — Sake 42 | Dest ans]        S, = (Diag (a) - (0. © k.) ke) ne
GDN [i11           8 lly — Ske |                                           S; = (I— B:kik!) Sia + Bike?
KDA (ours)          Be \la, — SI she |                                           S, = (I- Brkikj’) Diag (a)Si-1 + Bekvvy

For GDN and KDA, the update can be viewed as performing an Stochastic Gradient Descent(SGD) process on the decayed state S, that is, S, =
S:-1—Vg,_,£, where S;—1 is decayed by scalar or fine-grained gate.

§ 3.1), while switching to the more efficient recurrent kernel (Eq. 2) for autoregressive generation. A key advantage
of the Linear KDA is its ability to maintain a fixed-sized state (d, x d, per head, with d, = d, = 128) regardless of
sequence length. For our hybrid model, as sequence length increases, the I/O-bounded decoding time approaches a
maximum hybrid efficiency ratio of 3:1 compared to full attention. This trend is reflected in Fig. 7b, where Kimi Linear
achieves a 2.3 speedup at a 1M token context. Additionally, by eliminating the need for a large, linear-scaling KV
cache, Kimi Linear is able to reallocate memory resources to support larger batch sizes, enhancing overall throughput.
In long-context scenarios (up to 1M tokens), this memory efficiency results in a theoretical decoding speedup of up to
6.3x (see Fig. 1b).

7 Related Works

7.1 Efficient Subquadratic Attention

The quadratic time complexity of the standard self-attention mechanism [99] remains a fundamental bottleneck for
processing long contexts in Transformer-based models. This limitation has become increasingly critical as large
language models (LLMs) are now expected to handle million-token sequences for tasks such as agentic tool use and
repository-level code analysis [19, 50]. To overcome this challenge, a substantial body of research has explored more
efficient attention mechanisms [91, 89], which can broadly be categorized into two main directions: (1) linear attention,
and (2) sparse attention.

Linear Attention reformulates the quadratic attention map into kernelized feature interactions, replacing the softmax
with a positive feature map so that attention can be computed through two associative matrix products [48]. This
eliminates the explicit O(7) similarity matrix and enables linear-time computation with respect to sequence length.
Subsequent work strengthens the vanilla linear attention significantly through more refined memory control, shifting
from data-independent “decay” [92, 78] to more adaptive, data-dependent mechanisms [29, 93], and refining the decay
granularity from coarse headwise [16] to precise, channel-wise decay. GLA generalizes these approaches with diagonal,
channel-wise gates that balance expressiveness and efficiency while retaining chunk-wise parallelism [1 13, 114]. Table 7
summarizes the corresponding update rules. Collectively, these methods cast attention as a compact recurrent memory
updated with parallel prefix-scan operators and fused matrix multiplies, aligning well with modern accelerators [42].

A complementary view connects linear attention to fast-weight memory [84]: the state is a low-capacity associative
table updated online by Hebbian-like rules [69], while slow weights amortize when to store, update, or forget [68].

In Table 7, we provide a summary of the existing efficient token mixing methods, comparing them from the perspectives
of state update mechanisms and optimization objectives.

16


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

From this perspective, gating and decay serve as learnable criteria that mitigate interference and stabilize optimization
[90]. Despite these advances, linear attention still lags full attention on exact copying and fine-grained selection in
extreme long-context retrieval. This motivates hybrid designs (interleaving linear and full attention) and more structured
updates. In particular, the gated delta rule used by GDN/KDA introduces rank-1 corrective updates to the fast-weight
state, improving targeted retention while remaining parallelizable at the operator level [1 12].

Linear Attention with Gating Mechanism The vanilla Linear Attention [48] is known to lack the selection
mechanism inherent in softmax attention [99], falling short in expressiveness. To address this, Gated Linear Attention
models have emerged as memory-efficient and parallelizable alternatives [1 13, 114, 29]. Instead of storing an ever-
expanding KV cache, these models employ a fixed-size matrix-valued state and learnable gates to selectively retain
and forget information. This design achieves expressive power comparable to softmax attention [65, 125, 64] while
maintaining constant time and memory complexity during inference time. The general recurrent formulation of such
models for memory update S; € R¢**4» can be expressed as:

S,=A,S;1+kv, of =S) aq.                                    (15)

The primary distinction among various gated linear attention mechanisms lies in the parameterization of the forget gate
A,;, as summarized in Table 7. For instance, RetNet [92] uses a data-independent scalar decay a, and Mamba2 [16]
employs a data-dependent scalar a. Specifically, GLA [114] utilized a diagonalized fine-grained matrix Diag(a,;) €
R¢&*4«, offering an effective trade-off between efficiency and performance. Other variants are displayed in Table 7.

Sparse Attention A separate body of work reduces the quadratic complexity of standard attention by exploiting
its inherent sparsity, approximating the full attention score by performing the computation on a strategically selected
subset of tokens. The central challenge lies in identifying this subset effectively without degrading model performance.
Early methods often utilized efficient, training-free static patterns, such as sliding and dilated windows [20, 31, 107], or
fixed patterns [120, 35], but their rigid structure often compromises model accuracy. More advanced methods determine
the important positions based on the context, such as clustering [51, 106] and lightweight routing mechanisms [25, 73,
2, 9], but this dynamic selection process introduces a computational overhead that can prevent them from achieving
their full theoretical speedup without dedicated kernel acceleration [21]. Some models further introduce training-free
sparsification during the inference stage [107, 109].

Recent approaches to sparse attention have begun to prioritize hardware co-design, as exemplified by NSA [119,
96] and MoBA [63], which both move from token-level to chunk-level selection. In NSA, each query dynamically
selects chunks based on scores produced by an MLP. The method’s efficiency relies on its use of Grouped-Query
Attention (GQA) [98] with a large head count (typically a multiple of 16), a configuration specifically designed to
accelerate computation through highly parallelized tensor—matrix multiplications. Similarly, MoBA performs top-k
chunk selection, but leverages log-sum-exp (LSE) scores computed efficiently via flash-attention kernels [17]. In
contrast to NSA and MoBA, the recently proposed DeepSeek-V3.2-Exp Attention (DSA) [18] revives token-level
sparsity, maintaining efficiency through a learnable full-attention indexer implemented with low-precision fp8 and a
small head dimension for token selection.

Discussion Linear attention and sparse attention represent two distinct pathways toward efficient long-context
modeling. Sparse attention tends to retrieve fine-grained historical information more effectively, but this advantage
comes at the cost of storing the entire KV cache for token selection, making it less efficient than linear attention models
that maintain a constant state. Moreover, sparse attention performs only information selection, and its theoretical
expressive upper bound remains that of full attention. In contrast, linear attention, grounded in the principle of
“compression as intelligence”, enables generalization with a fixed-size state and, when combined with the Delta learning
tule, can achieve theoretically stronger expressive capacity. Although linear attentions have traditionally been criticized
for weak retrieval ability, this limitation can be mitigated through state expansion [23, 34, 117, 39] or related techniques.
Nevertheless, despite these advantages, linear attention remains limited by current hardware implementations and the
absence of optimized inference infrastructure. Our work overcomes these limitations with Kimi Linear, a powerful
model integrated with vLLM for efficient inference. Our proposed KDA delivers competitive performance compared
to the full-attention baseline (Table 3) and achieves over a 2x decoding speedup at the one-million-token context
(Figure 7b). Despite their distinct approaches to efficient long-context modeling, linear attention and sparse attention
are not mutually exclusive. Future work could explore hybrid models that integrate the strengths of both, leveraging
the compression and generalization capabilities of linear attention with the fine-grained retrieval advantages of sparse
attention to further enhance model performance and efficiency.

17


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

7.2 Hybrid Model

Despite efficiency, pure Linear Attention still struggle with precise memory retrieval and exact copying [45, 104] This
deficiency hinders their adoption in industrial-scale LLMs where robust long-context recall (e.g., beyond 1M tokens)
and reliable tool-use over extensive code repositories are critical [50]. Recent work shows that Linear Attention and full
attention can effectively complement each other, leading to various hybrid designs.

Intra-layer hybrid One category of hybrid architectures is the intra-layer hybrid, which adaptively fuses the outputs
of different mechanisms within each layer. A common implementation fuses outputs from heterogeneous heads within
each layer, such as combining standard attention with state space models (SSMs) [22, 56]. In contrast, sequence-level
approaches apply distinct mechanisms to different parts of the input. For example, some use linear attention for past
context and SWA for recent tokens [123, 54, 67], while NHA [24] compresses the history with GSA [124] and combines
it with local sliding window context to emulate a standard attention operation.

Inter-layer Hybrid A key drawback of the intra-layer hybrid is the increased system complexity and inference
overhead. The heterogeneous mechanisms require separate computational paths, complicating optimizations like
distributed parallelism. To mitigate this challenge, inter-layer hybrids have become a more widely adopted and practical
strategy in LLMs [66, 57, 97]. This approach involves stacking distinct layer types, such as full attention and a linear
alternative, in a predefined ratio. Building on this paradigm, we implement a simple yet effective strategy: interleaving
linear and full attention layers at a fixed 3:1 ratio (see § 5.2 for ablations). This regular, repeating structure simplifies
KV cache management and integrates seamlessly with standard optimizations. For the linear component of our hybrid,
we deviate from the common practice of using Mamba? [16]. Instead, we employ KDA, as we found it yields superior
overall performance, particularly in retrieval and copying abilities.

Discussion Recent work indicates that hybrid models can be sensitive to adjustments in the RoPE base frequency,
a vulnerability that complicates context window extension [126]. This sensitivity can hinder the model’s ability to
extrapolate to longer sequences. To address this challenge, recent models have trended towards solutions that incorporate
No Position Embeddings (NoPE). Falcon-H [126], for example, uses an unconventionally high base frequency (e.g.,
b = 101) to push its positional encoding to a near-NoPE state. Architecturally, SwanGPT [76] interleaves RoPE-based
layers with NoPE-based full attention layers. Aligning with this direction, we found that hybridizing our KDA layers
with NoPE full attention is also a highly effective strategy, facilitating straightforward context window extension.

Conclusion

We introduce Kimi Linear, a hybrid linear attention architecture designed to meet the efficiency demands of agentic
intelligence and test-time scaling without sacrificing quality. Central to Kimi Linear is Kimi Delta Attention (KDA), an
advanced linear attention module with a channel-wise gating mechanism that enhances memory control and enables
RNN-style models in hybrid architectures. By interleaving KDA with global attention in a 3:1 ratio, Kimi Linear reduces
memory usage by up to 75%, while achieving up to 6.3 x higher decoding throughput and outperforming full-attention
baselines. Our approach provides a scalable, efficient solution for large language models, with open-source KDA
kernels and pre-trained checkpoints facilitating further research.

18


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

References

Sandhini Agarwal et al. “gpt-oss-120b & gpt-oss-20b model card”. In: arXiv preprint arXiv:2508. 10925 (2025).
Joshua Ainslie et al. “Colt5: Faster long-range transformers with conditional computation”. In: arXiv preprint
arXiv:2303.09752 (2023).

Zeyuan Allen-Zhu. “Physics of Language Models: Part 4.1, Architecture Design and the Magic of Canon Layers”.
In: SSRN Electronic Journal (May 2025). Available at SSRN: https: //ssrn.com/abstract=5240330 or
http://dx.doi.org/10.2139/ssrn.5240330. DOI: 10.2139/ssrn.5240330.

Simran Arora et al. “Simple linear attention language models balance the recall-throughput tradeoff”. In:
Forty-first International Conference on Machine Learning. 2024. URL: https: //openreview.net/forum?
id=e93ffDcpH3.

Simran Arora et al. Zoology: Measuring and Improving Recall in Efficient Language Models. 2023. arXiv:
2312.04927 [cs.CL].

Yushi Bai et al. “Longbench v2: Towards deeper understanding and reasoning on realistic long-context multi-
tasks”. In: arXiv preprint arXiv:2412.15204 (2024).

Federico Barbero et al. “Round and Round We Go! What makes Rotary Positional Encodings useful?” In:
Proceedings of ICLR. 2025. URL: https: //openreview.net/forum?id=GtvuNrk58a.

Ali Behrouz et al. “Atlas: Learning to optimally memorize the context at test time’. In: arXiv preprint
arXiv:2505.23735 (2025).

Amanda Bertsch et al. “Unlimiformer: Long-range transformers with unlimited length input’. In: Advances in
NeurIPS 36 (2023), pp. 35522-35543.

Stella Biderman et al. “Lessons from the trenches on reproducible evaluation of language models”. In: arXiv
preprint arXiv:2405.14782 (2024).

Christian Bischof and Charles Van Loan. “The WY Representation for Products of Householder Matrices”. In:
SIAM Journal on Scientific and Statistical Computing (1987), s2-s13. URL: https: //doi.org/10.1137/
0908009.

Aaron Blakeman et al. “Nemotron-h: A family of accurate and efficient hybrid mamba-transformer models”. In:
arXiv preprint arXiv:2504.03624 (2025).

Egor Bogomolov et al. “Long code arena: a set of benchmarks for long-context code models”. In: arXiv preprint
arXiv:2406.11612 (2024).

Peter Clark et al. “Think you have Solved Question Answering? Try ARC, the AI2 Reasoning Challenge”. In:
arXiv: 1803.05457v1 (2018).

Ganqu Cui et al. “The entropy mechanism of reinforcement learning for reasoning language models”. In: arXiv
preprint arXiv:2505.22617 (2025).

Tri Dao and Albert Gu. “Transformers are SSMs: Generalized Models and Efficient Algorithms Through
Structured State Space Duality”. In: CoRR abs/2405.21060 (2024). DOI: 10.48550/ARXIV. 2405 . 21060.
arXiv: 2405.21060. URL: https: //doi.org/10.48550/arXiv.2405.21060.

Tri Dao et al. “FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness”. In: Advances
in NeurIPS. 2022, pp. 16344-16359. URL: https: //proceedings.neurips.cc/paper_files/paper/
2022/file/67d57c32e20fd0a7a302cb81d36e40d5- Paper-Conference.pdf.

DeepSeek-AI. DeepSeek-V3.2-Exp: Boosting Long-Context Efficiency with DeepSeek Sparse Attention. 2025.

DeepSeek-AI et al. DeepSeek-V3 Technical Report. 2025. arXiv: 2412.19437 [cs.CL]. URL: https: //
arxiv.org/abs/2412.19437.

Jiayu Ding et al. LongNet: Scaling Transformers to 1,000,000,000 Tokens. 2023. arXiv: 2307 .02486 [cs.CL].
URL: https: //arxiv.org/abs/2307 . 02486.

Juechu Dong et al. Flex Attention: A Programming Model for Generating Optimized Attention Kernels. 2024.
arXiv: 2412.05496 [cs.LG]. URL: https: //arxiv.org/abs/2412.05496.

Xin Dong et al. Hymba: A Hybrid-head Architecture for Small Language Models. 2024. arXiv: 2411 .13676
[cs.CL]. URL: https://arxiv.org/abs/2411.13676.

Jusen Du et al. “Mom: Linear sequence modeling with mixture-of-memories”. In: arXiv preprint
arXiv:2502.13685 (2025).

Jusen Du et al. “Native Hybrid Attention for Efficient Sequence Modeling”. In: arXiv preprint arXiv:2510.07019
(2025).

Tianyu Fu et al. “Moa: Mixture of sparse attention for automatic large language model compression”. In: arXiv
preprint arXiv:2406.14909 (2024).

19


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Aryo Pradipta Gema et al. “Are we done with mmlu?” In: arXiv preprint arXiv:2406.04127 (2024).

Riccardo Grazzi et al. “Unlocking State-Tracking in Linear RNNs Through Negative Eigenvalues”. In: Proceed-
ings of ICLR. 2025. URL: https: //openreview.net/forum?id=UvTo3tVBk2.

Joseph F. Grcar. “How ordinary elimination became Gaussian elimination”. In: Historia Mathematica 38.2
(May 2011), pp. 163-218. ISSN: 0315-0860. DOT: 10.1016/j.hm.2010.06.003. URL: http: //dx.doi.
org/10.1016/j .hm.2010.06.003.

Albert Gu and Tri Dao. Mamba: Linear-Time Sequence Modeling with Selective State Spaces. 2023. arXiv:
2312.00752 [cs.LG].

Albert Gu, Karan Goel, and Christopher Ré. Efficiently Modeling Long Sequences with Structured State Spaces.
2022. arXiv: 2111.00396 [cs.LG].

Xiangming Gu et al. When Attention Sink Emerges in Language Models: An Empirical View. 2025. arXiv:
2410.10781 [cs.CL]. URL: https: //arxiv.org/abs/2410.10781.

Yuxian Gu et al. Jet-Nemotron: Efficient Language Model with Post Neural Architecture Search. 2025. arXiv:
2508. 15884 [cs.CL]. URL: https: //arxiv.org/abs/2508. 15884.

Daya Guo et al. “DeepSeek-R1 incentivizes reasoning in LLMs through reinforcement learning”. In: Nature
645.8081 (2025), pp. 633-638.

Han Guo et al. “Log-linear attention”. In: arXiv preprint arXiv:2506.04761 (2025).

Qipeng Guo et al. “Star-transformer’. In: arXiv preprint arXiv: 1902.09113 (2019).

Dan Hendrycks et al. Measuring Massive Multitask Language Understanding. 2021. arXiv: 2009 . 03300
[cs.CY]. URL: https://arxiv.org/abs/2009 . 03300.

Jordan Hoffmann et al. Training Compute-Optimal Large Language Models. 2022. arXiv: 2203 . 15556
[cs.CL]. URL: https://arxiv.org/abs/2203. 15556.

Cheng-Ping Hsieh et al. “RULER: What’s the Real Context Size of Your Long-Context Language Models?” In:
arXiv preprint arXiv:2404.06654 (2024).

Jiaxi Hu et al. “Attractor memory for long-term time series forecasting: A chaos perspective”. In: Advances in
NeurIPS 37 (2024), pp. 20786-20818.

Jiaxi Hu et al. “Comba: Improving Nonlinear RNNs with Closed-loop Control”. In: arXiv preprint
arXiv:2506.02475 (2025).

Ermo Hua et al. “Fourier Position Embedding: Enhancing Attention’s Periodic Extension for Length General-
ization”. In: arXiv preprint arXiv:2412.17739 (2024).

Weizhe Hua et al. “Transformer Quality in Linear Time”. In: Proceedings of ICML. Ed. by Kamalika Chaudhuri
et al. PMLR, 2022, pp. 9099-9117. URL: https: //proceedings.mlr.press/v162/hua22a.html.
Yuzhen Huang et al. “C-eval: A multi-level multi-discipline chinese evaluation suite for foundation models”. In:

Advances in NeurIPS 36 (2023), pp. 62991-63010.

Naman Jain et al. “Livecodebench: Holistic and contamination free evaluation of large language models for
code”. In: arXiv preprint arXiv:2403.07974 (2024).

Samy Jelassi et al. Repeat After Me: Transformers are Better than State Space Models at Copying. 2024. arXiv:
2402.01032 [cs.LG].

Thierry Joffrain et al. “Accumulating Householder transformations, revisited”. In: (2006), pp. 169-179. URL:
https: //doi.org/10.1145/1141885.1141886.

Mandar Joshi et al. “Triviaqa: A large scale distantly supervised challenge dataset for reading comprehension”.
In: arXiv preprint arXiv:1705.03551 (2017).

Angelos Katharopoulos et al. “Transformers are RNNs: Fast Autoregressive Transformers with Linear Atten-
tion”. In: Proceedings of ICML. Ed. by Hal Daumé II] and Aarti Singh. PMLR, 2020, pp. 5156-5165. URL:
https: //proceedings.mlr.press/v119/katharopoulos20a. html.

Amirhossein Kazemnejad et al. “The impact of positional encoding on length generalization in transformers”’.
In: Advances in NeurIPS 36 (2023), pp. 24892-24928.

Team Kimi et al. “Kimi k2: Open agentic intelligence”. In: arXiv preprint arXiv:2507.20534 (2025).

Nikita Kitaev, Lukasz Kaiser, and Anselm Levskaya. “Reformer: The efficient transformer”. In: arXiv preprint
arXiv:2001.04451 (2020).

Satyapriya Krishna et al. “Fact, fetch, and reason: A unified evaluation of retrieval-augmented generation”. In:
arXiv preprint arXiv:2409.1294] (2024).

Hanyu Lai et al. “A Survey of Post-Training Scaling in Large Language Models”. In: Proceedings of the 63rd
Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). 2025, pp. 2771-
2791.

20


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Disen Lan et al. “Liger: Linearizing Large Language Models to Gated Recurrent Structures”. In: arXiv preprint
arXiv:2503.01496 (2025).

Haonan Li et al. “CMMLU: Measuring massive multitask language understanding in Chinese”. In: Findings
of the Association for Computational Linguistics: ACL 2024. Ed. by Lun-Wei Ku, Andre Martins, and Vivek
Srikumar. Bangkok, Thailand: Association for Computational Linguistics, Aug. 2024, pp. 11260-11285. DoT:
10. 18653/v1/2024. findings - acl. 671. URL: https: //aclanthology . org/ 2024 . findings -
acl.671/.

Yixing Li et al. “Transmamba: Flexibly switching between transformer and mamba”. In: arXiv preprint
arXiv:2503.24067 (2025).

Opher Lieber et al. Jamba: A Hybrid Transformer-Mamba Language Model. 2024. arXiv: 2403 . 19887
[cs.CL].

Zhixuan Lin et al. “Forgetting transformer: Softmax attention with a forget gate”. In: arXiv preprint
arXiv:2503.02130 (2025).

Bo Liu et al. “Longhorn: State Space Models are Amortized Online Learners”. In: ArXiv abs/2407.14207 (2024).
URL: https://api.semanticscholar.org/CorpusID: 271310065.

Jiawei Liu et al. “Is Your Code Generated by ChatGPT Really Correct? Rigorous Evaluation of Large Language
Models for Code Generation”. In: Thirty-seventh Conference on NeurIPS. 2023. URL: https: //openreview.
net/forum?id=1qvx610Cu7.

Jiawei Liu et al. “Repoqa: Evaluating long context code understanding”. In: arXiv preprint arXiv:2406.06025
(2024).

Jingyuan Liu et al. Muon is Scalable for LLM Training. 2025. arXiv: 2502.16982 [cs.LG]. URL: https:
//arxiv.org/abs/2502. 16982.

Enzhe Lu et al. MoBA: Mixture of Block Attention for Long-Context LLMs. 2025. arXiv: 2502.13189 [cs.LG].
URL: https://arxiv.org/abs/2502.13189.

William Merrill, Jackson Petty, and Ashish Sabharwal. “The illusion of state in state-space models”. In: arXiv
preprint arXiv:2404.08819 (2024).

William Merrill and Ashish Sabharwal. “The Parallelism Tradeoff: Limitations of Log-Precision Transformers”.
In: Transactions of the Association for Computational Linguistics 11 (2023), pp. 531-545. DOI: 10. 1162/
tacl_a_00562. URL: https://aclanthology.org/2023.tacl-1.31/.

MiniMax et al. MiniMax-01: Scaling Foundation Models with Lightning Attention. 2025. arXiv: 2501 .08313
[cs.CL].

Tsendsuren Munkhdalai, Manaal Faruqui, and Siddharth Gopal. Leave No Context Behind: Efficient Infinite
Context Transformers with Infini-attention. 2024. arXiv: 2404.07143 [cs.CL].

Tsendsuren Munkhdalai and Adam Trischler. Metalearning with Hebbian Fast Weights. 2018. arXiv: 1807.
05076 [cs.NE]. URL: https: //arxiv.org/abs/1807.05076.

Tsendsuren Munkhdalai et al. “Metalearned Neural Memory”. In: ArXiv abs/1907.09720 (2019). URL: https:
//api.semanticscholar.org/CorpusID:198179407.

Long Ouyang et al. “Training language models to follow instructions with human feedback”. In: Advances in
NeurIPS 35 (2022), pp. 27730-27744.

Bo Peng et al. RWKV-7 "Goose" with Expressive Dynamic State Evolution. 2025. arXiv: 2503.14456 [cs.CL].
Bowen Peng et al. “Yarn: Efficient context window extension of large language models”. In: arXiv preprint
arXiv:2309.00071 (2023).

Piotr Piekos, Robert Csordas, and Jiirgen Schmidhuber. “Mixture of Sparse Attention: Content-Based Learnable
Sparse Attention via Expert-Choice Routing”. In: arXiv preprint arXiv:2505.00315 (2025).

Aske Plaat et al. “Reasoning with large language models, a survey”. In: CoRR (2024).

Ofir Press, Noah Smith, and Mike Lewis. “Train Short, Test Long: Attention with Linear Biases Enables
Input Length Extrapolation”. In: Proceedings of ICLR. 2022. URL: https: //openreview.net/forum? id=
R8sQPpGCvo.

Krishna C. Puvvada et al. SWAN-GPT: An Efficient and Scalable Approach for Long-Context Language
Modeling. 2025. arXiv: 2504.08719 [cs.CL].

Zhen Qin et al. HGRN2: Gated Linear RNNs with State Expansion. 2024. arXiv: 2404.07904 [cs.CL].
Zhen Qin et al. TransNormerLLM: A Faster and Better Large Language Model with Improved TransNormer.
2024. arXiv: 2307.14995 [cs.CL].

Zihan Qiu et al. Gated Attention for Large Language Models: Non-linearity, Sparsity, and Attention-Sink-Free.
2025. arXiv: 2505.06708 [cs.CL].

21


===== PAGE BREAK =====

C3 Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

[100]

[101]
[102]

[103]
[104]
[105]

[106]

Xiaoye Qu et al. “A survey of efficient reasoning for large reasoning models: Language, multimodality, and
beyond”. In: arXiv preprint arXiv:2503.21614 (2025).

Qwen Team. Qwen3-Next: Towards Ultimate Training & Inference Efficiency. Accessed: 2025-10-27. Sept.
2025.

David Rein et al. “Gpqa: A graduate-level google-proof q&a benchmark”. In: First Conference on Language
Modeling. 2024.

Keisuke Sakaguchi et al. WinoGrande: An Adversarial Winograd Schema Challenge at Scale. 2019. arXiv:
1907.10641 [cs.CL]. URL: https: //arxiv.org/abs/1907.10641.

Imanol Schlag, Kazuki Irie, and Jiirgen Schmidhuber. “Linear Transformers Are Secretly Fast Weight Program-
mers”. In: Proceedings of ICML. Ed. by Marina Meila and Tong Zhang. PMLR, 2021, pp. 9355-9366. URL:
https: //proceedings.mlr.press/v139/schlag21a.html.

Imanol Schlag, Tsendsuren Munkhdalai, and Jiirgen Schmidhuber. Learning Associative Inference Using Fast
Weight Memory. 2021. arXiv: 2011.07831 [cs.LG]. URL: https: //arxiv.org/abs/2011.07831.

Peter Shaw, Jakob Uszkoreit, and Ashish Vaswani. Self-Attention with Relative Position Representations. 2018.
arXiv: 1803.02155 [cs.CL].

Jianlin Su. Linear Attention: A Brief History of Imitation, Innovation, and Feedback. June 2025. URL: https:
//kexue.fm/archives/11033.

Jianlin Su et al. “Roformer: Enhanced transformer with rotary position embedding”. In: Neurocomputing 568
(2024), p. 127063.

Weigao Sun et al. Speed Always Wins: A Survey on Efficient Architectures for Large Language Models. 2025.
arXiv: 2508.09834 [cs.CL]. URL: https: //arxiv.org/abs/2508 . 09834.

Yu Sun et al. “Learning to (Learn at Test Time): RNNs with Expressive Hidden States”. In: ArXiv abs/2407.04620
(2024). URL: https: //api.semanticscholar.org/CorpusID: 271039606.

Yutao Sun et al. “Efficient attention mechanisms for large language models: A survey”. In: arXiv preprint
arXiv:2507.19595 (2025).

Yutao Sun et al. Retentive Network: A Successor to Transformer for Large Language Models. 2023. arXiv:
2307 .08621 [cs.CL].

Yutao Sun et al. You Only Cache Once: Decoder-Decoder Architectures for Language Models. 2024. arXiv:
2405 .05254 [cs.CL]. URL: https://arxiv.org/abs/2405.05254.

Mirac Suzgun et al. “Challenging big-bench tasks and whether chain-of-thought can solve them”. In: arXiv
preprint arXiv:2210.09261 (2022).

Kimi Team et al. Kimi k1.5: Scaling Reinforcement Learning with LLMs. 2025. arXiv: 2501.12599 [cs. AT].
URL: https: //arxiv.org/abs/2501.12599.

MiniCPM Team et al. MiniCPM4: Ultra-Efficient LLMs on End Devices. 2025. arXiv: 2506.07900 [cs.CL].
URL: https: //arxiv.org/abs/2506 .07900.

Tencent Hunyuan Team et al. “Hunyuan-turbos: Advancing large language models through mamba-transformer
synergy and adaptive chain-of-thought”. In: arXiv preprint arXiv:2505.15431 (2025).

Hugo Touvron et al. LLaMA: Open and Efficient Foundation Language Models. 2023. arXiv: 2302. 13971
[cs.CL].

Ashish Vaswani et al. “Attention is All you Need”. In: Advances in NeurIPS. Ed. by I. Guyon et al. Curran
Associates, Inc., 2017. URL: https: //proceedings .neurips.cc/paper_files/paper/2017/file/
3£5ee243547dee91fbd053c1c4a845aa-Paper. pdf.

Roger Waleffe et al. An Empirical Study of Mamba-based Language Models. 2024. arXiv: 2406 . 07887
[cs.LG]. URL: https://arxiv.org/abs/2406 .07887.

Sinong Wang et al. Linformer: Self-Attention with Linear Complexity. 2020. arXiv: 2006 .04768 [cs.LG].

Yaoyu Wang. Understanding DeltaNet from the Perspective of Inference Frameworks. May 2025. URL: https:
//yywangcs .notion.site/DeltaNet-1fefc9f5d80580a496f 8eb406a496f09.

Yubo Wang et al. “Mmlu-pro: A more robust and challenging multi-task language understanding benchmark”’.
In: Advances in NeurIPS 37 (2024), pp. 95266-95290.

Kaiyue Wen, Xingyu Dang, and Kaifeng Lyu. “Rnns are not transformers (yet): The key bottleneck on in-context
retrieval’. In: arXiv preprint arXiv:2402.18510 (2024).

Colin White et al. “Livebench: A challenging, contamination-free Ilm benchmark”. In: arXiv preprint
arXiv:2406.19314 4 (2024).

Yuhuai Wu et al. “Memorizing transformers”. In: arXiv preprint arXiv:2203.08913 (2022).

22


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

[107]
[108]
[109]
[110]
[111]
[112]
[113]
[114]
[115]
[116]
[117]
[118]
[119]
[120]
[121]

[122]
[123]

[124]
[125]

[126]

Guangxuan Xiao et al. “Efficient streaming language models with attention sinks”. In: arXiv preprint
arXiv:2309. 17453 (2023).

Wenhan Xiong et al. Effective Long-Context Scaling of Foundation Models. 2023. arXiv: 2309 .16039 [cs.CL].
URL: https: //arxiv.org/abs/2309. 16039.

Ruyi Xu et al. “Xattention: Block sparse attention with antidiagonal scoring”. In: arXiv preprint
arXiv:2503.16428 (2025).

Bowen Yang et al. Rope to Nope and Back Again: A New Hybrid Attention Strategy. 2025. arXiv: 2501 .18795
[cs.CL]. URL: https://arxiv.org/abs/2501.18795.

Songlin Yang, Jan Kautz, and Ali Hatamizadeh. “Gated Delta Networks: Improving Mamba2 with Delta Rule”.
In: Proceedings of ICLR. 2025. URL: https: //openreview.net/forum? id=r8H7xhYPwz.

Songlin Yang and Bailin Wang. “Parallelizing Linear Transformers with the Delta Rule over Sequence Length”.
In: ArXiv abs/2406.06484 (2024). URL: https: //api.semanticscholar.org/CorpusID: 270371554.

Songlin Yang and Yu Zhang. FLA: A Triton-Based Library for Hardware-Efficient Implementations of Linear
Attention Mechanism. 2024. URL: https://github.com/fla-org/flash-linear-attention.

Songlin Yang et al. “Gated Linear Attention Transformers with Hardware-Efficient Training”. In: Proceedings
of ICML. PMLR, 2024.

Songlin Yang et al. “PaTH Attention: Position Encoding via Accumulating Householder Transformations”. In:
arXiv preprint arXiv:2505.16381 (2025).

Feng Yao et al. Your Efficient RL Framework Secretly Brings You Off-Policy RL Training. Aug. 2025. URL:
https: //fengyao.notion.site/off-policy-rl.

Morris Yau et al. “Sequential-Parallel Duality in Prefix Scannable Models”. In: arXiv preprint arXiv:2506.10918
(2025).

Howard Yen et al. “HELMET: How to Evaluate Long-Context Language Models Effectively and Thoroughly”.
In: International Conference on Learning Representations (ICLR). 2025.

Jingyang Yuan et al. Native Sparse Attention: Hardware-Aligned and Natively Trainable Sparse Attention. 2025.
arXiv: 2502.11089 [cs.CL]. URL: https: //arxiv.org/abs/2502.11089.

Manzil Zaheer et al. “Big bird: Transformers for longer sequences”. In: Advances in NeurIPS 33 (2020),
pp. 17283-17297.

Rowan Zellers et al. “HellaSwag: Can a Machine Really Finish Your Sentence?” In: Proceedings of the 57th
Annual Meeting of the Association for Computational Linguistics. 2019.

Biao Zhang and Rico Sennrich. “Root mean square layer normalization”. In: Advances in NeurIPS 32 (2019).

Michael Zhang et al. “Lolcats: On low-rank linearizing of large language models”. In: arXiv preprint
arXiv:2410.10254 (2024).

Yu Zhang et al. Gated Slot Attention for Efficient Linear-Time Sequence Modeling. 2024. arXiv: 2409 .07146
[cs.CL].

Shu Zhong et al. “Understanding Transformer from the Perspective of Associative Memory”. In: arXiv preprint
arXiv:2505.19488 (2025).

Jingwei Zuo et al. Falcon-H1: A Family of Hybrid-Head Language Models Redefining Efficiency and Perfor-
mance. 2025. arXiv: 2507.22448 [cs.CL]. URL: https: //arxiv.org/abs/2507 .22448.

23


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

A Contributions

The authors are listed in order of the significance of their contributions, with those in project leadership roles appearing
last. The project is developed at Moonshot AI, with several external collaborators that are marked with #. Names
marked with an asterisk (*) indicate people who are no longer part of our team.

Yu Zhang!                                                                  Junjie Yan
Zongyu Lin*                                                                    Zhejun Jiang
Xingcheng Yao                                                         Weixiao Huang
Jiaxi Hu?                                                                 Bohong Yin
Fanqing Meng                                                          Jiacheng You
Chengyin Liu                                                                Chu Wei

Xin Men                                                                       Zhengtao Wang
Songlin Yang*?                                                             Chao Hong
Zhiyuan Li                                                                 Yutian Chen
Wentao Li                                                                     Guanduo Chen
Enzhe Lu                                                                Yucheng Wang
Weizhou Liu                                                                    Huabin Zheng
Yanru Chen                                                                Feng Wang
Weixin Xu                                                                       Yibo Liu
Longhui Yu                                                                   Mengnan Dong
Yejie Wang                                                                 Zheng Zhang
Yu Fan                                                                       Siyuan Pan
Longguang Zhong                                                         Wenhao Wu
Enming Yuan                                                             Yuhao Wu
Dehao Zhang                                                                   Longyu Guan
Yizhi Zhang                                                                  Jiawen Tao
T.Y. Liu                                                                Guohong Fu* +
Haiming Wang                                                              Xinran Xu
Shengjun Fang                                                              Yuzhi Wang
Weiran He                                                                     Guokun Lai
Shaowei Liu                                                                 Yuxin Wu
Yiwei Li                                                                             Xinyu Zhou
Jianlin Su                                                                   Zhilin Yang
Jiezhong Qiu*                                                             Yulun Du

Bo Pang

! Soochow University, China
? The Hong Kong University of Science and Technology (Guangzhou)
3 Massachusetts Institute of Technology

4“ Hangzhou Institute of Medicine, CAS

24


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

B_ Derivations for Chunkwise Parallelism of KDA

We first recall the recurrent form of KDA:

t
Sig = (II (I Gigkigkiq ) Diag(a     »)  ‘Sty + y  I ("-       Biyki ki ) Dialed) | - Bighiyeig
i=l
eS SY

—————_$_—————————————

=P hy

= Pig Sig + Hig

Our goal is to transform Pry and

=H)

Hi, into matrix forms suitable for parallel computation.

We show that Pry , which involves the cumulative product of generalized Householder matrices, can be optimized using

the classic WY representation.

Proposition 1. The matrix Pi, can be expressed as:

-> Diag (yiq"” Rig @ fy}

(16)

where the auxiliary vector Wig € R% is computed via the following recurrence relation:

Sw Ca Diag (4° Ya ‘)a))           a7)

Proof. We proceed with a proof by mathematical induction.

wir = Fig  (Dive

Inductive Step: Assume the proposition holds for r — 1, i.e., Pi = Diag(yj,) °) —yyr} Diag(yj"" "Rij wiy-

We now derive:

Pig = (1— siyhight] ) Dias(ay Pig

I Bi kiki)
= (

ay

Diag (aj) we Vin)       -S Diag (vig     ee

= Diag(7{i)) — > Diag (4
w=1
= Diag(yf,) — $5 Diag (7

i=l

= Diag(7{i)) — > Diag (4

= Diag( Yiu)     -¥ Diag Gi

= Diag( Yi)     yo Diag (vi

The inductive step holds.

Similar to Pi)  H?

[t

t    ve k t

t    ) k t

t    ) k t

") Ri
‘Ki

WwW

Wh —

Wis

i=l

r

wee]

r    rv
ki Wha

j can also be expressed in a parallelizable form.

25

— Big kigkty Diag (yy) + Sty hig hig Ying (rf    ") kijwid

r-1

;

;

Tr   r  ry a   r      r    r      t    iTD;.    Ir  r

t (BiDiag (rj)  + kiy @ ty (Ki, Diag (vii )*))

—                       r-1  .
— kh  (%% (Diseevik — > wis

i=l


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

Proposition 2. The matrix H7,

(4) Can be expressed as:

Tr             :        ivr    a, tT
fy] = >_ Diag (vii ) igi                                       (18)
i=l
where the auxiliary vector Uy € R* is computed via the following recurrence relation:

ug = Bia (vi - ya (Ki,    {Diag (77°  ie)  a)                        (19)

Proof. We again use mathematical induction.

Inductive Step: Assume the proposition holds for r — 1.

Hfy = (I~ Sigkfghh] ) Diaslofy Hy + Bly hig ey
~ (1 — Bia  take ) Diag(aq)  (s Diag (5° ‘)kj ma i) + Biykig rey
= (1- Bea Rtg te, ) ( Diag (q"    ") biel] + Bighty Pi
r—1                                      r-1
_       :       imr    a   iT     rur pri       to    mr
-             _
>_ Diag (ai ieee] — Bey RG >_ Diag (iy) Rigel + Shhh etd
= yy Diag (+/5°" ) Riyuig        Ki (:  i] y (kif Diag (7°) iy) vis)   + key Bigried
~                                                                                     T
r-l
= -S Diag (vii      ") i  tig + ty | Bie (vi - » Ura (Ki Diag (va" ‘)a))
— Oe
ie)
r-1          ;       ;    _
= Yo Ding (ofg"”) Meld + Rigel
i=1
= 7 Diag (     )  (e] fe
1
The inductive step holds.                                                                                                                    |

26


===== PAGE BREAK =====

OMAN OOTP WHR DOWD AN DAF WN KB

WWNHNNNNNNNDN NY
FOO WON DOF WH KH OO

32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56

58

C3 Kimi Linear: An Expressive, Efficient Attention Architecture

TECHNICAL REPORT

Pseudo Code for chunkwise KDA

def

YY

chunk_kda(

q:
k:
v:

g:

torch.Tensor,
torch.Tensor,
torch.Tensor,
torch.Tensor,

beta: torch.Tensor,
initial_state: Optional[torch.Tensor] = None,

chunk_size:

q, k, v, g, beta =

int = 64

K, V, C=
Cc

map (
lambda x: rearrange(x, 'b (nc) h...
[q, k, v, g, beta]

*q.shape, v.shape[-1], chunk_size

> bhne...

', c=C).to(torch.float),

torch.triu(torch.ones(C, C, dtype=torch.bool, device=q.device), diagonal=0)

)

q=q * K**-0.5

g = g.cumsum(-2)

mask =

A = torch.zeros(B, H, N, C, C, dtype=torch.float, device=q.device)

for i in range(C):

A
#
A
f

A

W
u

iS}

k_i=k[..., i, :]
g_i=g[..., i:itl, :]

= k.new_zeros(B, H, K, V)

if initial_state is not None:

°
#

S += initial_state
= torch. zeros_like(v)
strictly lower triangular

A[..., i] = torch.einsum('... cd,     d ->     c', k * (g - g_i).exp(), k_i)

= A * beta[..., None]

matriz inverse by forward substitution

= -A.masked_fill(mask, 0)

or i in range(1, C):
A[L..., i, :i] = AL..., i, :i].clone(Q) + (AL..., i, :, None].clone() * AL..., :,
~~ :i].clone()).sum(-2)

= (A + torch.eye(C, dtype=torch.float, device=q.device)) * beta[..., None, :]

= A @ (g.expQ * k)

=AQv

mask = torch.triu(torch.ones(C, C, dtype=torch.bool, device=q.device), diagonal=1)
for i in range(0, N):

# (B, H, C, ...]
q_i, k_i, u_i, g_i, w_i = q[:,
A=

:, i], kc,

for j in range(C):

k_j = k0:, :, i, jl

gj=el:, :, i, j:j+l, :]

A[..., j] = torch.einsum('... c d,     d
A = A.masked_fill(mask, 0)
v_i=u_i-w_ios
o[:, :, i] = (q_i * g_i.exp()) @S+A@ vi
S = S$ * rearrange(g_i[:, :, -1].expQ,

S += rearrange((g_il:,

:, i], ul:,
torch.zeros(B, H, C, C, dtype=torch.float, device=q.device)
# secondary chunking for numerical stability

>...

:, i], wl:, :, i]

:, i], gl:,

c', q_i * (g_i - g_j).expQ, k_j)

'bhk->bhk 1')
:, -1:] - g_i).exp() * ki, 'bhck->bhkc') @ vi

return rearrange(o, 'b hncd->b (nc) h d').to(dtype)

Listing 1: Pseudo PyTorch-style code snippet for KDA chunked form.

27


===== PAGE BREAK =====

@ Kimi Linear: An Expressive, Efficient Attention Architecture         TECHNICAL REPORT

D_ Kimi Linear @5.7T results

Following Moonlight, we also trained Kimi Linear with an extended 5.7T token dataset to demonstrate its effectiveness.
With 3x sparsity and a new attention architecture design, Kimi Linear consistently outperforms Moonlight across nearly
all benchmarks, underscoring the efficacy of the new architecture. The results are shown in Table 8 for base model and
Table 9 for instruction tuned model. Moonlight-Instruct was not evaluated (“-”) on tasks exceeding its 8K context limit.

Kimi Linear@5.7T obtains a score of 94.8 on RULER at 1M context length. This long context performance reinforces
that Kimi Linear is a promising alternative to full-attention architectures, delivering comparable or superior results
while potentially offering more efficient resource utilization.

Table 8: Performance of Kimi-Linear-Base and Moonlight-Base across diverse tasks.

Benchmark                         #Shots | Kimi-Linear-Base Moonlight-Base

Architecture                              -                    MoE                        MoE
# Activated Params                   -                     3B                          3B

# Total Params                           -                     48B                          16B
Trained Tokens                          -                    5.7T                        5.7T
TriviaQA                              5-shots                75.2                         66.2
SimpleQA                                        5-shots                       10.1                                       5.6
General    MMLU-Pro                          5-shots                54.8                         42.4
MMLU-redux                       5-shots                79.7                         73.8
WinoGrande                                   5-shots                       81.5                                    74.6
GPQA-Diamond (avg@8) | 5-shots                       40.4                                     35.2
MATH                                 4-shots                58.5                         45.3
Math    GSM8k                                8-shots                86.3                         772
GSM8k-platinum                  8-shots                89.6                         79.4
CMATH                               6-shots                85.5                         79.6
CRUXEval-I-cot                            0-shots                        61.0                                      45.9
Code    CRUXEval-O-cot                 0-shots                67.0                         46.6
LiveCodeBench (v6)           1-shots             20.0                     14.3
EvalPlus                                    -                    64.9                         50.3
Chinese    C-Eval                                  5-shots                83.3                         77.6
.       CSimpleQA                          5-shots                53.5                         34.7

Table 9: Performance of Kimi-Linear-Instruct and Moonlight-Instruct across diverse tasks.

Benchmark                                           Kimi-Linear-Instruct Moonlight-Instruct
Architecture                                                              MoE                                          MoE
# Activated Params                                 3B                               3B
# Total Params                                                  48B                                       16B
Trained Tokens                                                        5.7T                                           5.7T
RULER @ 128k                                                        95.4                                               -
RULER @1M                       94.8                   -
General GPQA-Diamond (Avg @8)                                71.7                                           24.7
MMLU-Redux (EM)                                            86.9                                           66.9
MMLU-Pro (EM)                              72.7                         43.8
FaithJudge (1-Hallu.)                                           64.2                                           56.0
AIME 2025 (Avg @ 64)                                        58.6                                               -
Math MATHS00 (Acc.)                                                   94.6                                           58.0
HMMT 2025 (Avg @32)                                     44.5                                               -
LiveCodeBench v6 (Pass@ 1)                    45.7                                 11.9
Code   OJBench (Pass @ 1)                    14.2                   -
Humanevalt                                                              70.9                                           46.3
MBPP*                    72.4            56.3

28
